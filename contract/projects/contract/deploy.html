<!DOCTYPE html>
<html>
<head>
    <title>TrueRoots Contract Deployment</title>
    <script src="https://unpkg.com/algosdk@latest/dist/browser/algosdk.min.js"></script>
</head>
<body>
    <h1>TrueRoots Smart Contract Deployment</h1>
    
    <div>
        <h3>Step 1: Enter your mnemonic</h3>
        <textarea id="mnemonic" placeholder="Enter your 25-word mnemonic phrase" rows="3" cols="50"></textarea>
    </div>
    
    <div>
        <h3>Step 2: Contract Programs</h3>
                <textarea id="approvalProgram" placeholder="Paste the approval TEAL program here...">#pragma version 10
#pragma typetrack false

// @algorandfoundation/algorand-typescript/arc4/index.d.ts::Contract.approvalProgram() -> uint64:
main:
    intcblock 0 1
    bytecblock "status" "|" "auth_proc" "admin" "auth_lab" "reward_done" "batch_id" "lab_cert_cid" "QC_VERIFIED" "final_img_cid" "consumer_qr" "PROCESSED" "base_reward" "QC_PENDING" "geo" "species" "COLLECTED" "SHIPPED"
    // smart_contracts/true_roots/contract.algo.ts:26
    // export class TrueRoots extends Contract {
    txn NumAppArgs
    bz main_after_if_else@14
    pushbytess 0x64f09adf 0xd23e14c8 0x981185ac 0x87810098 0xfb324adc 0x7394d8a4 0xfc671f66 0x75f19f2f // method "createApplication(byte[],byte[],byte[],uint64,uint64)void", method "create_batch(byte[],byte[],uint64,byte[],byte[],uint64)void", method "verify_qc(byte[],uint64,uint64)void", method "process_batch(byte[],byte[],uint64)void", method "ship_batch()void", method "reward_distributed()void", method "update_auth(byte[],byte[],uint64)void", method "provenance()byte[]"
    txna ApplicationArgs 0
    match main_createApplication_route@3 main_create_batch_route@4 main_verify_qc_route@5 main_process_batch_route@6 main_ship_batch_route@7 main_reward_distributed_route@8 main_update_auth_route@9 main_provenance_route@10

main_after_if_else@14:
    // smart_contracts/true_roots/contract.algo.ts:26
    // export class TrueRoots extends Contract {
    intc_0 // 0
    return

main_provenance_route@10:
    // smart_contracts/true_roots/contract.algo.ts:159
    // @abimethod({ readonly: true })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub provenance
    dup
    len
    itob
    extract 6 2
    swap
    concat
    pushbytes 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_update_auth_route@9:
    // smart_contracts/true_roots/contract.algo.ts:150
    // @abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/true_roots/contract.algo.ts:26
    // export class TrueRoots extends Contract {
    txna ApplicationArgs 1
    extract 2 0
    txna ApplicationArgs 2
    extract 2 0
    txna ApplicationArgs 3
    btoi
    // smart_contracts/true_roots/contract.algo.ts:150
    // @abimethod()
    callsub update_auth
    intc_1 // 1
    return

main_reward_distributed_route@8:
    // smart_contracts/true_roots/contract.algo.ts:136
    // @abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub reward_distributed
    intc_1 // 1
    return

main_ship_batch_route@7:
    // smart_contracts/true_roots/contract.algo.ts:127
    // @abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub ship_batch
    intc_1 // 1
    return

main_process_batch_route@6:
    // smart_contracts/true_roots/contract.algo.ts:115
    // @abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/true_roots/contract.algo.ts:26
    // export class TrueRoots extends Contract {
    txna ApplicationArgs 1
    extract 2 0
    txna ApplicationArgs 2
    extract 2 0
    txna ApplicationArgs 3
    btoi
    // smart_contracts/true_roots/contract.algo.ts:115
    // @abimethod()
    callsub process_batch
    intc_1 // 1
    return

main_verify_qc_route@5:
    // smart_contracts/true_roots/contract.algo.ts:103
    // @abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/true_roots/contract.algo.ts:26
    // export class TrueRoots extends Contract {
    txna ApplicationArgs 1
    extract 2 0
    txna ApplicationArgs 2
    btoi
    txna ApplicationArgs 3
    btoi
    // smart_contracts/true_roots/contract.algo.ts:103
    // @abimethod()
    callsub verify_qc
    intc_1 // 1
    return

main_create_batch_route@4:
    // smart_contracts/true_roots/contract.algo.ts:89
    // @abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/true_roots/contract.algo.ts:26
    // export class TrueRoots extends Contract {
    txna ApplicationArgs 1
    extract 2 0
    txna ApplicationArgs 2
    extract 2 0
    txna ApplicationArgs 3
    btoi
    txna ApplicationArgs 4
    extract 2 0
    txna ApplicationArgs 5
    extract 2 0
    txna ApplicationArgs 6
    btoi
    // smart_contracts/true_roots/contract.algo.ts:89
    // @abimethod()
    callsub create_batch
    intc_1 // 1
    return

main_createApplication_route@3:
    // smart_contracts/true_roots/contract.algo.ts:60
    // createApplication(admin: bytes, lab: bytes, proc: bytes, rewardAsa: uint64, baseReward: uint64) {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    !
    assert // can only call when creating
    // smart_contracts/true_roots/contract.algo.ts:26
    // export class TrueRoots extends Contract {
    txna ApplicationArgs 1
    extract 2 0
    txna ApplicationArgs 2
    extract 2 0
    txna ApplicationArgs 3
    extract 2 0
    txna ApplicationArgs 4
    btoi
    txna ApplicationArgs 5
    btoi
    // smart_contracts/true_roots/contract.algo.ts:60
    // createApplication(admin: bytes, lab: bytes, proc: bytes, rewardAsa: uint64, baseReward: uint64) {
    callsub createApplication
    intc_1 // 1
    return


// smart_contracts/true_roots/contract.algo.ts::TrueRoots.createApplication(admin: bytes, lab: bytes, proc: bytes, rewardAsa: uint64, baseReward: uint64) -> void:
createApplication:
    // smart_contracts/true_roots/contract.algo.ts:60
    // createApplication(admin: bytes, lab: bytes, proc: bytes, rewardAsa: uint64, baseReward: uint64) {
    proto 5 0
    // smart_contracts/true_roots/contract.algo.ts:28
    // admin = GlobalState<bytes>();
    bytec_3 // "admin"
    // smart_contracts/true_roots/contract.algo.ts:62
    // this.admin.value = admin;
    frame_dig -5
    app_global_put
    // smart_contracts/true_roots/contract.algo.ts:29
    // auth_lab = GlobalState<bytes>();
    bytec 4 // "auth_lab"
    // smart_contracts/true_roots/contract.algo.ts:63
    // this.auth_lab.value = lab;
    frame_dig -4
    app_global_put
    // smart_contracts/true_roots/contract.algo.ts:30
    // auth_proc = GlobalState<bytes>();
    bytec_2 // "auth_proc"
    // smart_contracts/true_roots/contract.algo.ts:64
    // this.auth_proc.value = proc;
    frame_dig -3
    app_global_put
    // smart_contracts/true_roots/contract.algo.ts:33
    // reward_asa = GlobalState<uint64>();
    pushbytes "reward_asa"
    // smart_contracts/true_roots/contract.algo.ts:65
    // this.reward_asa.value = rewardAsa;
    frame_dig -2
    app_global_put
    // smart_contracts/true_roots/contract.algo.ts:34
    // base_reward = GlobalState<uint64>();
    bytec 12 // "base_reward"
    // smart_contracts/true_roots/contract.algo.ts:66
    // this.base_reward.value = baseReward;
    frame_dig -1
    app_global_put
    // smart_contracts/true_roots/contract.algo.ts:35
    // reward_done = GlobalState<uint64>(); // 0/1
    bytec 5 // "reward_done"
    // smart_contracts/true_roots/contract.algo.ts:67
    // this.reward_done.value = Uint64(0);
    intc_0 // 0
    app_global_put
    // smart_contracts/true_roots/contract.algo.ts:44
    // status = GlobalState<bytes>();
    bytec_0 // "status"
    // smart_contracts/true_roots/contract.algo.ts:7
    // export const STATUS_QC_PENDING = Bytes("QC_PENDING");
    bytec 13 // "QC_PENDING"
    // smart_contracts/true_roots/contract.algo.ts:68
    // this.status.value = STATUS_QC_PENDING;
    app_global_put
    retsub


// smart_contracts/true_roots/contract.algo.ts::TrueRoots.onlyAdmin() -> void:
onlyAdmin:
    // smart_contracts/true_roots/contract.algo.ts:75
    // assert(Txn.sender.bytes.equals(this.admin.value), ERR_NOT_ADMIN);
    txn Sender
    // smart_contracts/true_roots/contract.algo.ts:28
    // admin = GlobalState<bytes>();
    intc_0 // 0
    bytec_3 // "admin"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/true_roots/contract.algo.ts:75
    // assert(Txn.sender.bytes.equals(this.admin.value), ERR_NOT_ADMIN);
    ==
    assert // E_ADMIN
    retsub


// smart_contracts/true_roots/contract.algo.ts::TrueRoots.create_batch(batch_id: bytes, collector: bytes, collected_at: uint64, geo: bytes, species: bytes, quantity_kg: uint64) -> void:
create_batch:
    // smart_contracts/true_roots/contract.algo.ts:89-90
    // @abimethod()
    // create_batch(batch_id: bytes, collector: bytes, collected_at: uint64, geo: bytes, species: bytes, quantity_kg: uint64) {
    proto 6 0
    // smart_contracts/true_roots/contract.algo.ts:38
    // batch_id = GlobalState<bytes>();
    intc_0 // 0
    bytec 6 // "batch_id"
    // smart_contracts/true_roots/contract.algo.ts:91
    // assert(!this.batch_id.hasValue, ERR_EXISTS);
    app_global_get_ex
    bury 1
    !
    assert // E_EXISTS
    // smart_contracts/true_roots/contract.algo.ts:92
    // assert(quantity_kg > 0, ERR_QTY);
    frame_dig -1
    assert // E_QTY
    // smart_contracts/true_roots/contract.algo.ts:38
    // batch_id = GlobalState<bytes>();
    bytec 6 // "batch_id"
    // smart_contracts/true_roots/contract.algo.ts:93
    // this.batch_id.value = batch_id;
    frame_dig -6
    app_global_put
    // smart_contracts/true_roots/contract.algo.ts:39
    // collector = GlobalState<bytes>();
    pushbytes "collector"
    // smart_contracts/true_roots/contract.algo.ts:94
    // this.collector.value = collector;
    frame_dig -5
    app_global_put
    // smart_contracts/true_roots/contract.algo.ts:40
    // collected_at = GlobalState<uint64>();
    pushbytes "collected_at"
    // smart_contracts/true_roots/contract.algo.ts:95
    // this.collected_at.value = collected_at;
    frame_dig -4
    app_global_put
    // smart_contracts/true_roots/contract.algo.ts:41
    // geo = GlobalState<bytes>(); // "lat,lng"
    bytec 14 // "geo"
    // smart_contracts/true_roots/contract.algo.ts:96
    // this.geo.value = geo;
    frame_dig -3
    app_global_put
    // smart_contracts/true_roots/contract.algo.ts:42
    // species = GlobalState<bytes>();
    bytec 15 // "species"
    // smart_contracts/true_roots/contract.algo.ts:97
    // this.species.value = species;
    frame_dig -2
    app_global_put
    // smart_contracts/true_roots/contract.algo.ts:43
    // quantity_kg = GlobalState<uint64>();
    pushbytes "quantity_kg"
    // smart_contracts/true_roots/contract.algo.ts:98
    // this.quantity_kg.value = quantity_kg;
    frame_dig -1
    app_global_put
    // smart_contracts/true_roots/contract.algo.ts:44
    // status = GlobalState<bytes>();
    bytec_0 // "status"
    // smart_contracts/true_roots/contract.algo.ts:6
    // export const STATUS_COLLECTED = Bytes("COLLECTED");
    bytec 16 // "COLLECTED"
    // smart_contracts/true_roots/contract.algo.ts:99
    // this.status.value = STATUS_COLLECTED;
    app_global_put
    retsub


// smart_contracts/true_roots/contract.algo.ts::TrueRoots.verify_qc(lab_cert_cid: bytes, authenticity_score: uint64, qc_at: uint64) -> void:
verify_qc:
    // smart_contracts/true_roots/contract.algo.ts:103-104
    // @abimethod()
    // verify_qc(lab_cert_cid: bytes, authenticity_score: uint64, qc_at: uint64) {
    proto 3 0
    // smart_contracts/true_roots/contract.algo.ts:78
    // assert(Txn.sender.bytes.equals(this.auth_lab.value), ERR_NOT_LAB);
    txn Sender
    // smart_contracts/true_roots/contract.algo.ts:29
    // auth_lab = GlobalState<bytes>();
    intc_0 // 0
    bytec 4 // "auth_lab"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/true_roots/contract.algo.ts:78
    // assert(Txn.sender.bytes.equals(this.auth_lab.value), ERR_NOT_LAB);
    ==
    assert // E_LAB
    // smart_contracts/true_roots/contract.algo.ts:44
    // status = GlobalState<bytes>();
    intc_0 // 0
    bytec_0 // "status"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/true_roots/contract.algo.ts:6
    // export const STATUS_COLLECTED = Bytes("COLLECTED");
    bytec 16 // "COLLECTED"
    // smart_contracts/true_roots/contract.algo.ts:106
    // assert(this.status.value.equals(STATUS_COLLECTED) || this.status.value.equals(STATUS_QC_PENDING), ERR_BAD_STATUS);
    ==
    bnz verify_qc_bool_true@2
    // smart_contracts/true_roots/contract.algo.ts:44
    // status = GlobalState<bytes>();
    intc_0 // 0
    bytec_0 // "status"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/true_roots/contract.algo.ts:7
    // export const STATUS_QC_PENDING = Bytes("QC_PENDING");
    bytec 13 // "QC_PENDING"
    // smart_contracts/true_roots/contract.algo.ts:106
    // assert(this.status.value.equals(STATUS_COLLECTED) || this.status.value.equals(STATUS_QC_PENDING), ERR_BAD_STATUS);
    ==
    bz verify_qc_bool_false@3

verify_qc_bool_true@2:
    intc_1 // 1

verify_qc_bool_merge@4:
    // smart_contracts/true_roots/contract.algo.ts:106
    // assert(this.status.value.equals(STATUS_COLLECTED) || this.status.value.equals(STATUS_QC_PENDING), ERR_BAD_STATUS);
    assert // E_STATUS
    // smart_contracts/true_roots/contract.algo.ts:107
    // assert(authenticity_score <= Uint64(100), ERR_SCORE);
    frame_dig -2
    pushint 100 // 100
    <=
    assert // E_SCORE
    // smart_contracts/true_roots/contract.algo.ts:47
    // lab_cert_cid = GlobalState<bytes>();
    bytec 7 // "lab_cert_cid"
    // smart_contracts/true_roots/contract.algo.ts:108
    // this.lab_cert_cid.value = lab_cert_cid;
    frame_dig -3
    app_global_put
    // smart_contracts/true_roots/contract.algo.ts:49
    // authenticity_score = GlobalState<uint64>();
    pushbytes "authenticity_score"
    // smart_contracts/true_roots/contract.algo.ts:109
    // this.authenticity_score.value = authenticity_score;
    frame_dig -2
    app_global_put
    // smart_contracts/true_roots/contract.algo.ts:48
    // qc_at = GlobalState<uint64>();
    pushbytes "qc_at"
    // smart_contracts/true_roots/contract.algo.ts:110
    // this.qc_at.value = qc_at;
    frame_dig -1
    app_global_put
    // smart_contracts/true_roots/contract.algo.ts:44
    // status = GlobalState<bytes>();
    bytec_0 // "status"
    // smart_contracts/true_roots/contract.algo.ts:8
    // export const STATUS_QC_VERIFIED = Bytes("QC_VERIFIED");
    bytec 8 // "QC_VERIFIED"
    // smart_contracts/true_roots/contract.algo.ts:111
    // this.status.value = STATUS_QC_VERIFIED;
    app_global_put
    retsub

verify_qc_bool_false@3:
    intc_0 // 0
    b verify_qc_bool_merge@4


// smart_contracts/true_roots/contract.algo.ts::TrueRoots.process_batch(final_img_cid: bytes, consumer_qr: bytes, proc_at: uint64) -> void:
process_batch:
    // smart_contracts/true_roots/contract.algo.ts:115-116
    // @abimethod()
    // process_batch(final_img_cid: bytes, consumer_qr: bytes, proc_at: uint64) {
    proto 3 0
    // smart_contracts/true_roots/contract.algo.ts:81
    // assert(Txn.sender.bytes.equals(this.auth_proc.value), ERR_NOT_PROC);
    txn Sender
    // smart_contracts/true_roots/contract.algo.ts:30
    // auth_proc = GlobalState<bytes>();
    intc_0 // 0
    bytec_2 // "auth_proc"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/true_roots/contract.algo.ts:81
    // assert(Txn.sender.bytes.equals(this.auth_proc.value), ERR_NOT_PROC);
    ==
    assert // E_PROC
    // smart_contracts/true_roots/contract.algo.ts:44
    // status = GlobalState<bytes>();
    intc_0 // 0
    bytec_0 // "status"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/true_roots/contract.algo.ts:8
    // export const STATUS_QC_VERIFIED = Bytes("QC_VERIFIED");
    bytec 8 // "QC_VERIFIED"
    // smart_contracts/true_roots/contract.algo.ts:118
    // assert(this.status.value.equals(STATUS_QC_VERIFIED), ERR_BAD_STATUS);
    ==
    assert // E_STATUS
    // smart_contracts/true_roots/contract.algo.ts:54
    // final_img_cid = GlobalState<bytes>();
    bytec 9 // "final_img_cid"
    // smart_contracts/true_roots/contract.algo.ts:119
    // this.final_img_cid.value = final_img_cid;
    frame_dig -3
    app_global_put
    // smart_contracts/true_roots/contract.algo.ts:55
    // consumer_qr = GlobalState<bytes>();
    bytec 10 // "consumer_qr"
    // smart_contracts/true_roots/contract.algo.ts:120
    // this.consumer_qr.value = consumer_qr;
    frame_dig -2
    app_global_put
    // smart_contracts/true_roots/contract.algo.ts:53
    // proc_at = GlobalState<uint64>();
    pushbytes "proc_at"
    // smart_contracts/true_roots/contract.algo.ts:121
    // this.proc_at.value = proc_at;
    frame_dig -1
    app_global_put
    // smart_contracts/true_roots/contract.algo.ts:52
    // processor = GlobalState<bytes>();
    pushbytes "processor"
    // smart_contracts/true_roots/contract.algo.ts:122
    // this.processor.value = Txn.sender.bytes;
    txn Sender
    app_global_put
    // smart_contracts/true_roots/contract.algo.ts:44
    // status = GlobalState<bytes>();
    bytec_0 // "status"
    // smart_contracts/true_roots/contract.algo.ts:9
    // export const STATUS_PROCESSED = Bytes("PROCESSED");
    bytec 11 // "PROCESSED"
    // smart_contracts/true_roots/contract.algo.ts:123
    // this.status.value = STATUS_PROCESSED;
    app_global_put
    retsub


// smart_contracts/true_roots/contract.algo.ts::TrueRoots.ship_batch() -> void:
ship_batch:
    // smart_contracts/true_roots/contract.algo.ts:130
    // assert(Txn.sender.bytes.equals(this.admin.value) || Txn.sender.bytes.equals(this.auth_proc.value), ERR_NOT_PROC);
    txn Sender
    // smart_contracts/true_roots/contract.algo.ts:28
    // admin = GlobalState<bytes>();
    intc_0 // 0
    bytec_3 // "admin"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/true_roots/contract.algo.ts:130
    // assert(Txn.sender.bytes.equals(this.admin.value) || Txn.sender.bytes.equals(this.auth_proc.value), ERR_NOT_PROC);
    ==
    bnz ship_batch_bool_true@2
    txn Sender
    // smart_contracts/true_roots/contract.algo.ts:30
    // auth_proc = GlobalState<bytes>();
    intc_0 // 0
    bytec_2 // "auth_proc"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/true_roots/contract.algo.ts:130
    // assert(Txn.sender.bytes.equals(this.admin.value) || Txn.sender.bytes.equals(this.auth_proc.value), ERR_NOT_PROC);
    ==
    bz ship_batch_bool_false@3

ship_batch_bool_true@2:
    intc_1 // 1

ship_batch_bool_merge@4:
    // smart_contracts/true_roots/contract.algo.ts:130
    // assert(Txn.sender.bytes.equals(this.admin.value) || Txn.sender.bytes.equals(this.auth_proc.value), ERR_NOT_PROC);
    assert // E_PROC
    // smart_contracts/true_roots/contract.algo.ts:44
    // status = GlobalState<bytes>();
    intc_0 // 0
    bytec_0 // "status"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/true_roots/contract.algo.ts:9
    // export const STATUS_PROCESSED = Bytes("PROCESSED");
    bytec 11 // "PROCESSED"
    // smart_contracts/true_roots/contract.algo.ts:131
    // assert(this.status.value.equals(STATUS_PROCESSED), ERR_BAD_STATUS);
    ==
    assert // E_STATUS
    // smart_contracts/true_roots/contract.algo.ts:44
    // status = GlobalState<bytes>();
    bytec_0 // "status"
    // smart_contracts/true_roots/contract.algo.ts:10
    // export const STATUS_SHIPPED = Bytes("SHIPPED");
    bytec 17 // "SHIPPED"
    // smart_contracts/true_roots/contract.algo.ts:132
    // this.status.value = STATUS_SHIPPED;
    app_global_put
    retsub

ship_batch_bool_false@3:
    intc_0 // 0
    b ship_batch_bool_merge@4


// smart_contracts/true_roots/contract.algo.ts::TrueRoots.reward_distributed() -> void:
reward_distributed:
    // smart_contracts/true_roots/contract.algo.ts:138
    // this.onlyAdmin();
    callsub onlyAdmin
    // smart_contracts/true_roots/contract.algo.ts:35
    // reward_done = GlobalState<uint64>(); // 0/1
    intc_0 // 0
    bytec 5 // "reward_done"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/true_roots/contract.algo.ts:139
    // assert(this.reward_done.value === Uint64(0), ERR_REWARD_DONE);
    !
    assert // E_REWARD_DONE
    // smart_contracts/true_roots/contract.algo.ts:44
    // status = GlobalState<bytes>();
    intc_0 // 0
    bytec_0 // "status"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/true_roots/contract.algo.ts:8
    // export const STATUS_QC_VERIFIED = Bytes("QC_VERIFIED");
    bytec 8 // "QC_VERIFIED"
    // smart_contracts/true_roots/contract.algo.ts:141
    // this.status.value.equals(STATUS_QC_VERIFIED) ||
    ==
    // smart_contracts/true_roots/contract.algo.ts:141-142
    // this.status.value.equals(STATUS_QC_VERIFIED) ||
    //   this.status.value.equals(STATUS_PROCESSED) ||
    bnz reward_distributed_bool_true@3
    // smart_contracts/true_roots/contract.algo.ts:44
    // status = GlobalState<bytes>();
    intc_0 // 0
    bytec_0 // "status"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/true_roots/contract.algo.ts:9
    // export const STATUS_PROCESSED = Bytes("PROCESSED");
    bytec 11 // "PROCESSED"
    // smart_contracts/true_roots/contract.algo.ts:142
    // this.status.value.equals(STATUS_PROCESSED) ||
    ==
    // smart_contracts/true_roots/contract.algo.ts:141-142
    // this.status.value.equals(STATUS_QC_VERIFIED) ||
    //   this.status.value.equals(STATUS_PROCESSED) ||
    bnz reward_distributed_bool_true@3
    // smart_contracts/true_roots/contract.algo.ts:44
    // status = GlobalState<bytes>();
    intc_0 // 0
    bytec_0 // "status"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/true_roots/contract.algo.ts:10
    // export const STATUS_SHIPPED = Bytes("SHIPPED");
    bytec 17 // "SHIPPED"
    // smart_contracts/true_roots/contract.algo.ts:143
    // this.status.value.equals(STATUS_SHIPPED),
    ==
    // smart_contracts/true_roots/contract.algo.ts:141-143
    // this.status.value.equals(STATUS_QC_VERIFIED) ||
    //   this.status.value.equals(STATUS_PROCESSED) ||
    //   this.status.value.equals(STATUS_SHIPPED),
    bz reward_distributed_bool_false@4

reward_distributed_bool_true@3:
    intc_1 // 1

reward_distributed_bool_merge@5:
    // smart_contracts/true_roots/contract.algo.ts:140-145
    // assert(
    //   this.status.value.equals(STATUS_QC_VERIFIED) ||
    //     this.status.value.equals(STATUS_PROCESSED) ||
    //     this.status.value.equals(STATUS_SHIPPED),
    //   ERR_BAD_STATUS
    // );
    assert // E_STATUS
    // smart_contracts/true_roots/contract.algo.ts:35
    // reward_done = GlobalState<uint64>(); // 0/1
    bytec 5 // "reward_done"
    // smart_contracts/true_roots/contract.algo.ts:146
    // this.reward_done.value = Uint64(1);
    intc_1 // 1
    app_global_put
    retsub

reward_distributed_bool_false@4:
    intc_0 // 0
    b reward_distributed_bool_merge@5


// smart_contracts/true_roots/contract.algo.ts::TrueRoots.update_auth(new_lab: bytes, new_proc: bytes, new_base_reward: uint64) -> void:
update_auth:
    // smart_contracts/true_roots/contract.algo.ts:150-151
    // @abimethod()
    // update_auth(new_lab: bytes, new_proc: bytes, new_base_reward: uint64) {
    proto 3 0
    // smart_contracts/true_roots/contract.algo.ts:152
    // this.onlyAdmin();
    callsub onlyAdmin
    // smart_contracts/true_roots/contract.algo.ts:29
    // auth_lab = GlobalState<bytes>();
    bytec 4 // "auth_lab"
    // smart_contracts/true_roots/contract.algo.ts:153
    // this.auth_lab.value = new_lab;
    frame_dig -3
    app_global_put
    // smart_contracts/true_roots/contract.algo.ts:30
    // auth_proc = GlobalState<bytes>();
    bytec_2 // "auth_proc"
    // smart_contracts/true_roots/contract.algo.ts:154
    // this.auth_proc.value = new_proc;
    frame_dig -2
    app_global_put
    // smart_contracts/true_roots/contract.algo.ts:34
    // base_reward = GlobalState<uint64>();
    bytec 12 // "base_reward"
    // smart_contracts/true_roots/contract.algo.ts:155
    // this.base_reward.value = new_base_reward;
    frame_dig -1
    app_global_put
    retsub


// smart_contracts/true_roots/contract.algo.ts::TrueRoots.provenance() -> bytes:
provenance:
    // smart_contracts/true_roots/contract.algo.ts:159-160
    // @abimethod({ readonly: true })
    // provenance(): bytes {
    proto 0 1
    // smart_contracts/true_roots/contract.algo.ts:38
    // batch_id = GlobalState<bytes>();
    intc_0 // 0
    bytec 6 // "batch_id"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/true_roots/contract.algo.ts:162
    // let sep = Bytes("|");
    bytec_1 // "|"
    // smart_contracts/true_roots/contract.algo.ts:163-164
    // let out = this.batch_id.value
    //   .concat(sep)
    concat
    // smart_contracts/true_roots/contract.algo.ts:44
    // status = GlobalState<bytes>();
    intc_0 // 0
    bytec_0 // "status"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/true_roots/contract.algo.ts:163-165
    // let out = this.batch_id.value
    //   .concat(sep)
    //   .concat(this.status.value)
    concat
    // smart_contracts/true_roots/contract.algo.ts:162
    // let sep = Bytes("|");
    bytec_1 // "|"
    // smart_contracts/true_roots/contract.algo.ts:163-166
    // let out = this.batch_id.value
    //   .concat(sep)
    //   .concat(this.status.value)
    //   .concat(sep)
    concat
    // smart_contracts/true_roots/contract.algo.ts:42
    // species = GlobalState<bytes>();
    intc_0 // 0
    bytec 15 // "species"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/true_roots/contract.algo.ts:163-167
    // let out = this.batch_id.value
    //   .concat(sep)
    //   .concat(this.status.value)
    //   .concat(sep)
    //   .concat(this.species.value)
    concat
    // smart_contracts/true_roots/contract.algo.ts:162
    // let sep = Bytes("|");
    bytec_1 // "|"
    // smart_contracts/true_roots/contract.algo.ts:163-168
    // let out = this.batch_id.value
    //   .concat(sep)
    //   .concat(this.status.value)
    //   .concat(sep)
    //   .concat(this.species.value)
    //   .concat(sep)
    concat
    // smart_contracts/true_roots/contract.algo.ts:41
    // geo = GlobalState<bytes>(); // "lat,lng"
    intc_0 // 0
    bytec 14 // "geo"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/true_roots/contract.algo.ts:163-169
    // let out = this.batch_id.value
    //   .concat(sep)
    //   .concat(this.status.value)
    //   .concat(sep)
    //   .concat(this.species.value)
    //   .concat(sep)
    //   .concat(this.geo.value)
    concat
    // smart_contracts/true_roots/contract.algo.ts:162
    // let sep = Bytes("|");
    bytec_1 // "|"
    // smart_contracts/true_roots/contract.algo.ts:163-170
    // let out = this.batch_id.value
    //   .concat(sep)
    //   .concat(this.status.value)
    //   .concat(sep)
    //   .concat(this.species.value)
    //   .concat(sep)
    //   .concat(this.geo.value)
    //   .concat(sep);
    concat
    dup
    // smart_contracts/true_roots/contract.algo.ts:47
    // lab_cert_cid = GlobalState<bytes>();
    intc_0 // 0
    bytec 7 // "lab_cert_cid"
    // smart_contracts/true_roots/contract.algo.ts:171
    // if (this.lab_cert_cid.hasValue) out = out.concat(this.lab_cert_cid.value);
    app_global_get_ex
    bury 1
    bz provenance_after_if_else@2
    // smart_contracts/true_roots/contract.algo.ts:47
    // lab_cert_cid = GlobalState<bytes>();
    intc_0 // 0
    bytec 7 // "lab_cert_cid"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/true_roots/contract.algo.ts:171
    // if (this.lab_cert_cid.hasValue) out = out.concat(this.lab_cert_cid.value);
    frame_dig 0
    swap
    concat
    frame_bury 1

provenance_after_if_else@2:
    frame_dig 1
    // smart_contracts/true_roots/contract.algo.ts:162
    // let sep = Bytes("|");
    bytec_1 // "|"
    // smart_contracts/true_roots/contract.algo.ts:172
    // out = out.concat(sep);
    concat
    dup
    frame_bury 0
    // smart_contracts/true_roots/contract.algo.ts:54
    // final_img_cid = GlobalState<bytes>();
    intc_0 // 0
    bytec 9 // "final_img_cid"
    // smart_contracts/true_roots/contract.algo.ts:173
    // if (this.final_img_cid.hasValue) out = out.concat(this.final_img_cid.value);
    app_global_get_ex
    bury 1
    swap
    frame_bury 1
    bz provenance_after_if_else@4
    // smart_contracts/true_roots/contract.algo.ts:54
    // final_img_cid = GlobalState<bytes>();
    intc_0 // 0
    bytec 9 // "final_img_cid"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/true_roots/contract.algo.ts:173
    // if (this.final_img_cid.hasValue) out = out.concat(this.final_img_cid.value);
    frame_dig 0
    swap
    concat
    frame_bury 1

provenance_after_if_else@4:
    frame_dig 1
    // smart_contracts/true_roots/contract.algo.ts:162
    // let sep = Bytes("|");
    bytec_1 // "|"
    // smart_contracts/true_roots/contract.algo.ts:174
    // out = out.concat(sep);
    concat
    dup
    frame_bury 0
    // smart_contracts/true_roots/contract.algo.ts:55
    // consumer_qr = GlobalState<bytes>();
    intc_0 // 0
    bytec 10 // "consumer_qr"
    // smart_contracts/true_roots/contract.algo.ts:175
    // if (this.consumer_qr.hasValue) out = out.concat(this.consumer_qr.value);
    app_global_get_ex
    bury 1
    swap
    frame_bury 1
    bz provenance_after_if_else@6
    // smart_contracts/true_roots/contract.algo.ts:55
    // consumer_qr = GlobalState<bytes>();
    intc_0 // 0
    bytec 10 // "consumer_qr"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/true_roots/contract.algo.ts:175
    // if (this.consumer_qr.hasValue) out = out.concat(this.consumer_qr.value);
    frame_dig 0
    swap
    concat
    frame_bury 1

provenance_after_if_else@6:
    frame_dig 1
    // smart_contracts/true_roots/contract.algo.ts:176
    // return out;
    frame_bury 0
    retsub</textarea>
                <textarea id="clearProgram" placeholder="Paste the clear TEAL program here...">#pragma version 10
#pragma typetrack false

// smart_contracts/true_roots/contract.algo.ts::TrueRoots.clearStateProgram() -> uint64:
main:
    // smart_contracts/true_roots/contract.algo.ts:181
    // return true;
    pushint 1 // 1
    return</textarea>
    </div>
    
    <button onclick="deployContract()">Deploy Contract</button>
    
    <div id="status"></div>
    <div id="result"></div>
    
    <script>
        async function deployContract() {
            const status = document.getElementById('status');
            const result = document.getElementById('result');
            
            try {
                status.innerHTML = 'Deploying...';
                
                // Setup
                const mnemonic = document.getElementById('mnemonic').value;
                const account = algosdk.mnemonicToSecretKey(mnemonic);
                
                const algodClient = new algosdk.Algodv2('', 'https://testnet-api.algonode.cloud', 443);
                
                // Check balance
                const accountInfo = await algodClient.accountInformation(account.addr).do();
                status.innerHTML = `Account: ${account.addr}<br>Balance: ${Number(accountInfo.amount) / 1000000} ALGO`;
                
                if (Number(accountInfo.amount) < 1000000) {
                    throw new Error('Insufficient balance. Fund your account at https://testnet.algoexplorer.io/dispenser');
                }
                
                // Compile programs
                const approvalSource = document.getElementById('approvalProgram').value;
                const clearSource = document.getElementById('clearProgram').value;
                
                const approvalCompiled = await algodClient.compile(approvalSource).do();
                const clearCompiled = await algodClient.compile(clearSource).do();
                
                // Get suggested params
                const suggestedParams = await algodClient.getTransactionParams().do();
                
                // Create app args
                const appArgs = [
                    algosdk.decodeAddress(account.addr).publicKey, // admin
                    algosdk.decodeAddress(account.addr).publicKey, // lab  
                    algosdk.decodeAddress(account.addr).publicKey, // processor
                    algosdk.encodeUint64(0), // rewardAsa
                    algosdk.encodeUint64(1000000), // baseReward
                ];
                
                // Create transaction
                const appCreateTxn = algosdk.makeApplicationCreateTxnFromObject({
                    sender: account.addr,
                    suggestedParams,
                    approvalProgram: new Uint8Array(Buffer.from(approvalCompiled.result, 'base64')),
                    clearProgram: new Uint8Array(Buffer.from(clearCompiled.result, 'base64')),
                    numGlobalInts: 8,
                    numGlobalByteSlices: 10,
                    numLocalInts: 0,
                    numLocalByteSlices: 0,
                    appArgs,
                    onComplete: algosdk.OnApplicationComplete.NoOpOC,
                });
                
                // Sign and send
                const signedTxn = appCreateTxn.signTxn(account.sk);
                await algodClient.sendRawTransaction(signedTxn).do();
                
                // Wait for confirmation
                const txResult = await algosdk.waitForConfirmation(algodClient, appCreateTxn.txID(), 4);
                
                const appId = txResult.applicationIndex;
                result.innerHTML = `
                    <h3>✅ Contract Deployed Successfully!</h3>
                    <p><strong>App ID:</strong> ${appId}</p>
                    <p><strong>Transaction ID:</strong> ${appCreateTxn.txID()}</p>
                    <p><a href="https://testnet.algoexplorer.io/application/${appId}" target="_blank">View on AlgoExplorer</a></p>
                `;
                
            } catch (error) {
                result.innerHTML = `<h3>❌ Error:</h3><p>${error.message}</p>`;
            }
        }
    </script>
</body>
</html>